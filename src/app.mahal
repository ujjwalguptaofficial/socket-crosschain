---
name: app.mahal
description: This component is the main parent component which is used to initiate the app.
dateCreated:
---

<html>
<div class="container is-flex is-flex-direction-column is-align-items-center">
	<div :if(isConnected) class="mt-6">
		WalletAddress : {{walletAddress}}
		
		<div class="mt-2 is-primary">
			<button class="button" @click="transfer" :class="{'is-loading':isTransfering}">Transfer cross chain</button>
		</div>
	</div>
	<ConnectToWallet :else @connect="onConnectToWallet" />
</div>
</html>

<script>
import { Component, children, reactive } from "mahal";
import MahalIntro from "@/components/mahal_intro.mahal";
import ConnectToWallet from "@/components/connect_to_wallet.mahal";
import { providers, BigNumber, constants } from "ethers";
import { ChainId, Socket, Path } from "@socket.tech/socket-v2-sdk";
import { SocketApiService } from "@/services";

@children({
    MahalIntro,
    ConnectToWallet,
})
export default class extends Component {
    @reactive isConnected;

    web3Provider: providers.Web3Provider;

    @reactive walletAddress: string;
    @reactive isTransfering = false;

    service = new SocketApiService();

    async onConnectToWallet(provider) {
        this.isConnected = true;
        const web3Provider = new providers.Web3Provider(provider);
        this.web3Provider = web3Provider;
        this.walletAddress = await this.web3Provider.getSigner().getAddress();
    }

    async getChains() {
        const response = await this.service.getChains();
        return response.result;
    }

    async transfer() {
        this.isTransfering = true;

        // this is our chainid
        const fromChainId = 137;
        const toChainId = 1;

        // check if chainids are supported by socket

        const chainAvailables: any[] = await this.getChains();
        const chainIdNeeded = [fromChainId, toChainId];
        let isNotSupported = false;
        chainIdNeeded.forEach((chain) => {
            if (!chainAvailables.find((q) => q.chainId == chain)) {
                isNotSupported = true;
            }
        });

        const responseForFromTokens = await this.service
            .getFromTokensList(fromChainId, toChainId)
            .then((response) => response.result);

        const responseForToTokens = await this.service
            .getToTokensList(fromChainId, toChainId)
            .then((response) => response.result);

        const tokenFrom = responseForFromTokens.find((token) => {
            return token.symbol === "MATIC";
        });
        const tokenTo = responseForToTokens.find((token) => {
            return token.symbol === "MATIC";
        });

        const quotes = await this.service
            .getQuotes({
                from: this.walletAddress,
                to: this.walletAddress,
                fromAmount: 100,
                fromChainId: fromChainId,
                toChainId: toChainId,
                fromTokenAddress: tokenFrom.address,
                toTokenAddress: tokenTo.address,
            })
            .then((response) => {
                return response.result;
            });
        if (quotes.routes.length === 0) {
            return alert("No quote found");
        }

        // route choosen - for simplicity let's choose first route
        const routeChoosen = quotes.routes[0];
        let routeStartResponse = await this.service.startRoute(
            routeChoosen,
            fromChainId,
            toChainId,
            tokenFrom.address,
            tokenTo.address
        );
        const signer = this.web3Provider.getSigner();
        if (routeStartResponse.success) {
            // execute first transaction

            const routeResult = routeStartResponse.result;

            let userTxCount = routeResult.totalUserTx;
            let currentTxIndex = routeResult.userTxIndex;
            let activeRouteId = routeResult.activeRouteId;
            let status = "ready";
            let txHash;

            var handleTxExecution = async (payload) => {
                const targetChainId = payload.chainId;
                currentTxIndex = payload.userTxIndex;

                // switch to targetChainId if not
                const currentChainId = await signer.getChainId();
                if (targetChainId !== currentChainId) {
                    alert(
                        `expected chainId ${targetChainId} but found ${currentChainId}`
                    );
                    return;
                }

                const { approvalData, txTarget } = payload;
                // approve tx if approval data

                if (approvalData) {
                    // check if approval needed
                    let {
                        owner,
                        allowanceTarget,
                        approvalTokenAddress,
                        minimumApprovalAmount,
                    } = approvalData;
                    if (!allowanceTarget) {
                        allowanceTarget = txTarget;
                    }
                    const allowanceResponse = await this.service.getAllowance(
                        targetChainId,
                        owner,
                        allowanceTarget,
                        approvalTokenAddress
                    );

                    const allowance = allowanceResponse.result;

                    const allowanceValue = BigNumber.from(allowance.value);
                    const minimumApprovalAmountBN = BigNumber.from(
                        minimumApprovalAmount
                    );
                    // allownace is less than minimum required
                    if (allowanceValue.lt(minimumApprovalAmountBN)) {
                        // allow max value

                        const approvalTxDataResponse =
                            await this.service.getApprovalCallData(
                                targetChainId,
                                owner,
                                allowanceTarget,
                                approvalTokenAddress,
                                constants.MaxUint256
                            );
                        const payload = approvalTxDataResponse.result;
                        debugger;
                        const approvalTx = await signer.sendTransaction({
                            data: payload.data,
                            to: approvalTokenAddress,
                        });
                        approvalTx.wait();
                    }
                }

                // eth_sendTransaction
                const tx = await signer.sendTransaction({
                    data: payload.txData,
                    to: txTarget,
                });
                txHash = tx.hash;

                executeAndCheck();
            };

            var executeAndCheck = async () => {
                if (currentTxIndex >= userTxCount) {
                    // tx finished
                    return;
                }

                // wait for 1 second and then check for status
                await new Promise((res) => {
                    setTimeout(res, 1000);
                });
                try {
                    // check for tx status
                    debugger;
                    const response = await this.service.checkTxStatus(
                        activeRouteId,
                        currentTxIndex,
                        txHash
                    );
                    debugger;
                    switch (response.result.toLowerCase()) {
                        case "failed":
                            alert("transaction failed");
                            break;
                        case "ready":
                            //fetch tx data from build apiKey
                            const response = await this.service.buildNextTx(
                                activeRouteId
                            );
                            handleTxExecution(response.result);
                            return;
                        case "pending":
                        case "completed":
                        default:
                            executeAndCheck();
                    }
                } catch (ex) {
                    console.log(ex);
                    executeAndCheck();
                }
            };

            handleTxExecution(routeStartResponse.result);
        }

        return;

        const socket = new Socket({
            apiKey: "645b2c8c-5825-4930-baf3-d9b997fcd88c",
        });

        const web3Socket = socket.connect(this.web3Provider);

        const tokenList = await socket.getTokenList({
            fromChainId: ChainId.POLYGON_CHAIN_ID, // Ethereum Mainnet
            toChainId: ChainId.MAINNET_CHAIN_ID, // Polygon Mainnet,
        });

        console.log("tokenList", tokenList);
        // return;

        const ethOnFromChain = tokenList.from.tokenBySymbol("MATIC");
        const ethOnToChain = tokenList.to.tokenBySymbol("MATIC");

        const path = new Path({
            fromToken: ethOnFromChain,
            toToken: ethOnToChain,
        });

        const quote = await socket.getBestQuote({
            path,
            amount: "100", // 1 ETH
            address: this.walletAddress,
        });

        console.log("quote", quote);

        const tx = await web3Socket.start(quote, {
            onDone: (activeRouteId) => {
                console.log("Executing route complete", activeRouteId);
            },
            onTx(tx) {
                console.log("tx", tx);
            },
        });

        this.isTransfering = false;
    }
}
</script>

<style>
</style>
